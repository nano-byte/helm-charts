{
  "$schema": "https://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "description": "The name of the service (used for app.kubernetes.io/name label)"
    },
    "fullname": {
      "type": "string",
      "description": "The name of the service instance (used for resource names and app.kubernetes.io/instance label)"
    },
    "version": {
      "type": "string",
      "description": "The version of the service (used for app.kubernetes.io/version label)"
    },
    "image": {
      "type": "object",
      "properties": {
        "registry": {
          "type": "string",
          "default": "docker.io",
          "description": "The Registry containing the image to run"
        },
        "repository": {
          "type": "string",
          "description": "The name of the image image to run (without the Registry)"
        },
        "tag": {
          "type": "string",
          "description": "The tag of the image to run; start with @ for digest instead of tag (e.g., @sha256:abc...)"
        },
        "pullPolicy": {
          "type": "string",
          "enum": ["Never", "IfNotPresent", "Always"],
          "default": "IfNotPresent",
          "description": "Set to Always to try to pull new versions of the image"
        },
        "pullSecret": {
          "type": "string",
          "description": "Name of the Kubernetes Secret providing credentials for pulling the image"
        }
      },
      "required": [
        "repository",
        "tag"
      ],
      "additionalProperties": false
    },
    "securityContext": {
      "type": "object",
      "description": "Security context",
      "properties": {
        "pod": {
          "type": "object",
          "description": "Security context to use for the pod",
          "properties": {
            "runAsUser": {"type": "integer"},
            "runAsGroup": {"type": "integer"},
            "fsGroup": {"type": "integer"}
          }
        },
        "container": {
          "type": "object",
          "description": "Security context to use for running containers",
          "properties": {
            "allowPrivilegeEscalation": {"type": "boolean"},
            "readOnlyRootFilesystem": {"type": "boolean"}
          }
        }
      },
      "additionalProperties": false
    },
    "command": {
      "type": "array",
      "items": {"type": "string"},
      "description": "Overrides the command to launch in the image"
    },
    "args": {
      "type": "array",
      "items": {"type": "string"},
      "description": "The command-line arguments passed to the service"
    },
    "env": {
      "type": "object",
      "additionalProperties": {"type": ["string", "number", "boolean"]},
      "description": "Environment variables passed to the service as a key-value map"
    },
    "envFrom": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "fieldRef": {"type": "object"},
          "resourceFieldRef": {"type": "object"},
          "configMapKeyRef": {"type": "object"},
          "secretKeyRef": {"type": "object"}
        }
      },
      "description": "Environment variables passed to the service from other sources (e.g., secretKeyRef)"
    },
    "config": {
      "type": "object",
      "description": "YAML/JSON configuration to be mounted as a file in the container"
    },
    "configMountPath": {
      "type": "string",
      "default": "/config/config.yaml",
      "description": "The file path in the container to mount the data from config into (exposed via $CONFIG_FILE)"
    },
    "additionalConfigs": {
      "type": "array",
      "items": {"type": "string"},
      "description": "Additional ConfigMaps with key named data.yaml to be mounted (paths appended to $CONFIG_FILE)"
    },
    "dnsConfig": {
      "type": "object",
      "properties": {
        "nameservers": {"type": "array", "items": {"type": "string"}},
        "searches": {"type": "array", "items": {"type": "string"}},
        "options": {"type": "array", "items": {"type": "object"}}
      },
      "description": "DNS config for the pod (https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/"
    },
    "startupProbe": {
      "type": "object",
      "description": "Probe that waits for the service to initially start",
      "properties": {
        "initialDelaySeconds": {"type": "integer"},
        "periodSeconds": {"type": "integer"},
        "httpGet": {
          "type": ["object", "null"],
          "properties": {
            "port": {"type": "string"},
            "path": {"type": "string"}
          },
          "additionalProperties": true
        },
        "grpc": {
          "type": ["object", "null"],
          "properties": {
            "port": {"type": "integer"}
          },
          "additionalProperties": true
        },
        "exec": {
          "type": ["object", "null"],
          "properties": {
            "command": {
              "type": "array",
              "items": {"type": "string"}
            },
            "additionalProperties": true
          }
        },
        "additionalProperties": true
      }
    },
    "livenessProbe": {
      "type": "object",
      "description": "Probe that causes the service to be restarted when failing",
      "properties": {
        "initialDelaySeconds": {"type": "integer"},
        "periodSeconds": {"type": "integer"},
        "httpGet": {
          "type": ["object", "null"],
          "properties": {
            "port": {"type": "string"},
            "path": {"type": "string"}
          },
          "additionalProperties": true
        },
        "grpc": {
          "type": ["object", "null"],
          "properties": {
            "port": {"type": "integer"}
          },
          "additionalProperties": true
        },
        "exec": {
          "type": ["object", "null"],
          "properties": {
            "command": {
              "type": "array",
              "items": {"type": "string"}
            }
          },
          "additionalProperties": true
        }
      },
      "additionalProperties": true
    },
    "readinessProbe": {
      "type": "object",
      "description": "Probe that prevents the service from receiving traffic when failing",
      "properties": {
        "initialDelaySeconds": {"type": "integer"},
        "periodSeconds": {"type": "integer"},
        "httpGet": {
          "type": ["object", "null"],
          "properties": {
            "port": {"type": "string"},
            "path": {"type": "string"}
          },
          "additionalProperties": true
        },
        "grpc": {
          "type": ["object", "null"],
          "properties": {
            "port": {"type": "integer"}
          },
          "additionalProperties": true
        },
        "exec": {
          "type": ["object", "null"],
          "properties": {
            "command": {
              "type": "array",
              "items": {"type": "string"}
            }
          },
          "additionalProperties": true
        }
      },
      "additionalProperties": true
    },
    "maxShutdownSeconds": {
      "type": "integer",
      "default": 30,
      "description": "The number of seconds the pod has to shutdown before it is terminated"
    },
    "labels": {
      "type": "object",
      "additionalProperties": {"type": "string"},
      "description": "Additional labels to set on all generated resources"
    },
    "annotations": {
      "type": "object",
      "additionalProperties": {"type": "string"},
      "description": "Additional annotations to set on the Pod controller and Pods"
    },
    "resources": {
      "type": "object",
      "properties": {
        "requests": {
          "type": "object",
          "properties": {
            "memory": {
              "type": "string",
              "default": "64M",
              "description": "The amount of memory requested for the service (recommendation: slightly higher than average usage)"
            },
            "cpu": {
              "type": "string",
              "default": "10m",
              "description": "The number of CPU cores requested for the service"
            }
          }
        },
        "limits": {
          "type": "object",
          "properties": {
            "memory": {
              "type": "string",
              "default": "96Mi",
              "description": "The maximum amount of memory the service may use (recommendation: slightly higher than worst-case usage)"
            },
            "cpu": {
              "type": "string",
              "default": "2000m",
              "description": "The maximum number of CPU cores the service may use"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "rollout": {
      "type": "object",
      "properties": {
        "controller": {
          "type": "string",
          "enum": ["Deployment", "StatefulSet", "DaemonSet", "ArgoRollout"],
          "default": "Deployment",
          "description": "The type of Pod controller to create"
        },
        "strategy": {
          "type": "string",
          "enum": ["RollingUpdate", "Recreate", "OnDelete", "Canary", "BlueGreen"],
          "default": "RollingUpdate",
          "description": "The rollout strategy"
        },
        "autoPromotion": {
          "type": "boolean",
          "default": true,
          "description": "Automatically promote successful rollouts (only applicable if rollout.strategy is BlueGreen)"
        },
        "flagger": {
          "type": "boolean",
          "default": false,
          "description": "Use Flagger to control rollouts (rollout.controller must be Deployment or StatefulSet)"
        },
        "analysis": {
          "description": "Flagger or Argo Rollouts analysis for automatic Canary or BlueGreen promotion"
        },
        "revisionHistoryLimit": {
          "type": ["integer", "null"],
          "description": "Number of old ReplicaSets to retain (rollout.controller must be Deployment or ArgoRollout)"
        }
      },
      "additionalProperties": false
    },
    "replicas": {
      "type": "integer",
      "default": 1,
      "description": "The number of instances of the service to run (set at least 2 for Pod Disruption Budget)"
    },
    "autoscaling": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Enables automatic starting of additional instances"
        },
        "maxReplicas": {
          "type": "integer",
          "default": 3,
          "description": "The maximum number of instances to run (must be larger than replicas)"
        },
        "metric": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": ["Resource", "Pods", "Object", "External"],
              "default": "Resource",
              "description": "The type of metric to use for scaling"
            },
            "name": {
              "type": "string",
              "default": "cpu",
              "description": "The name of the metric to use for scaling"
            },
            "object": {
              "type": ["object", "null"],
              "properties": {
                "apiVersion": {"type": "string"},
                "kind": {"type": "string"},
                "name": {"type": "string"}
              },
              "required": ["apiVersion", "kind", "name"],
              "description": "Reference to the Kubernetes object the metric describes (required if type = Object)"
            },
            "selector": {
              "type": "object",
              "additionalProperties": {"type": "string"},
              "description": "Labels for selecting the metric"
            }
          }
        },
        "targetValue": {
          "type": "integer",
          "default": 80,
          "description": "The desired value of the metric to achieve through scaling (e.g., CPU utilization in percent)"
        },
        "behavior": {
          "type": "object",
          "description": "Scaling behavior configuration (see HorizontalPodAutoscalerBehavior)"
        }
      },
      "additionalProperties": false
    },
    "scheduling": {
      "type": "object",
      "properties": {
        "priority": {
          "type": "string",
          "description": "The name of the PriorityClass to use for scheduling this service"
        },
        "nodeSelector": {
          "type": "object",
          "additionalProperties": {"type": "string"},
          "description": "Labels to select nodes this service may be run on"
        },
        "nodePreferences": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {"type": "string"}
          },
          "description": "Sets of label values to select nodes this service should be run on if possible"
        },
        "nodeExclusions": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {"type": "string"}
          },
          "description": "Sets of label values to select nodes this service must not run on"
        },
        "tolerations": {
          "type": "array",
          "items": {"type": "string"},
          "description": "Taints on nodes this service can tolerate"
        },
        "podAffinity": {
          "type": "object",
          "additionalProperties": {"type": "string"},
          "description": "Labels to select other pods this service should share nodes with if possible"
        },
        "podAntiAffinity": {
          "type": "object",
          "additionalProperties": {"type": "string"},
          "description": "Labels to select other pods this service must not share nodes with"
        },
        "replicaSpread": {
          "type": "string",
          "enum": ["BestEffort", "Strict", "None"],
          "default": "BestEffort",
          "description": "How to spread replicas across nodes"
        }
      },
      "additionalProperties": false
    },
    "persistence": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Enables persistent storage for the service"
        },
        "storageClass": {
          "type": "string",
          "description": "The type of disk to use for storage instead of the cluster default"
        },
        "accessModes": {
          "type": "array",
          "default": ["ReadWriteOnce"],
          "items": {"type": "string"},
          "description": "The support access modes the volume can be mounted with"
        },
        "size": {
          "type": "string",
          "default": "1G",
          "description": "The size of the persistent volume to create for the service"
        },
        "mountPath": {
          "type": "string",
          "description": "The mount path for the storage inside the container"
        }
      },
      "additionalProperties": false
    },
    "secrets": {
      "type": "object",
      "additionalProperties":
      {
        "type": "object",
        "properties": {
          "mountPath": {
            "type": "string",
            "description": "The mount path for the Secret inside the container"
          },
          "subPath": {
            "type": "string",
            "description": "The path of a single file in the Secret to mount; leave empty to mount all files"
          },
          "files": {
            "type": "object",
            "additionalProperties": {"type": "string"},
            "description": "Map of file names to base64-encoded content; leave empty to reference existing Secret"
          }
        },
        "required": [
          "mountPath"
        ],
        "additionalProperties": false
      }
    },
    "additionalMounts": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the volume"
          }
        },
        "required": ["name"],
        "additionalProperties": true
      },
      "description": "A map of mount paths inside the container to volumes"
    },
    "ingress": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Enables ingress into the service (either cluster-internal or public)"
        },
        "port": {
          "type": "integer",
          "default": 80,
          "description": "The container port ingress traffic is routed to"
        },
        "protocol": {
          "type": "string",
          "default": "http",
          "enum": ["http", "https", "h2c", "grpc", "http2", "h2", "grpcs"],
          "description": "The internal protocol used for ingress"
        },
        "timeoutSeconds": {
          "type": ["integer", "null"],
          "description": "Number of seconds after which to timeout waiting for response from service; -1 for infinite"
        },
        "domains": {
          "type": "array",
          "items": {"type": "string"},
          "description": "The public domain names under which the service is exposed (leave empty for cluster-internal only)"
        },
        "paths": {
          "type": "array",
          "items": {"type": "string"},
          "description": "HTTP path prefixes to accept ingress traffic for (leave empty to accept traffic for any path)"
        },
        "tls": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": false,
              "description": "Enables TLS termination at the ingress (not applicable if ingress.istio.enabled)"
            },
            "secret": {
              "type": "string",
              "default": "{{ .Release.Name }}-tls",
              "description": "The name of the Secret holding the TLS private key (not applicable if ingress.istio.enabled)"
            },
            "secretNamespace": {
              "type": "string",
              "description": "The Kubernetes namespace containing the Secret (only applicable if ingress.class is contour)"
            }
          },
          "additionalProperties": false
        },
        "cors": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": false,
              "description": "Enables CORS (only applicable if ingress.class is 'nginx' or ingress.istio.enabled is true)"
            },
            "allowOrigin": {
              "type": "array",
              "items": {"type": "string"},
              "description": "List of origins allowed to access the ingress via CORS; leave empty to allow any"
            },
            "allowMethods": {
              "type": "array",
              "items": {"type": "string"},
              "default": ["GET"],
              "description": "List of HTTP methods allowed to access the ingress via CORS"
            },
            "allowHeaders": {
              "type": "array",
              "items": {"type": "string"},
              "default": ["Content-Type"],
              "description": "List of HTTP headers that can be used when requesting the ingress via CORS"
            },
            "allowCredentials": {
              "type": "boolean",
              "default": true,
              "description": "Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials"
            },
            "exposeHeaders": {
              "type": "array",
              "items": {"type": "string"},
              "description": "List of HTTP headers that the browsers are allowed to access"
            }
          },
          "additionalProperties": false
        },
        "class": {
          "type": "string",
          "description": "The ingress controller to use (not applicable if ingress.istio.enabled)"
        },
        "annotations": {
          "type": "object",
          "additionalProperties": {"type": "string"},
          "description": "Annotations for Ingress or VirtualService resource"
        },
        "headless": {
          "type": "boolean",
          "default": false,
          "description": "Creates an additional Service with the suffix '-headless' that directly exposes Pod IPs"
        },
        "headlessExposesAll": {
          "type": "boolean",
          "default": false,
          "description": "Exposes all replicas, including unready ones, via the '-headless' Service"
        },
        "nodeLocal": {
          "type": "boolean",
          "default": false,
          "description": "Creates an additional Service with the suffix '-local' that only routes to pods on the same node"
        },
        "additionalSelectors": {
          "type": "object",
          "additionalProperties": {"type": "string"},
          "description": "Additional label selectors used to restrict the Pods selected by the Service."
        },
        "istio": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": false,
              "description": "Use Istio VirtualService instead of Kubernetes Ingress resource"
            },
            "gateways": {
              "type": "array",
              "items": {"type": "string"},
              "description": "The names of the Istio Gateways to use"
            },
            "httpHeaders": {
              "type": "object",
              "additionalProperties": {"type": "string"},
              "description": "Custom HTTP response headers"
            },
            "retries": {
              "type": "object",
              "description": "Istio retry policy (see https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRetry)"
            }
          },
          "additionalProperties": false
        },
        "extra": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "class": {
                "type": "string",
                "description": "Additional ingress controller to use (not applicable if ingress.istio.enabled)"
              },
              "port": {
                "type": "integer",
                "description": "The container port ingress traffic is routed to; defaults to value of ingress.port if not set"
              },
              "portRef": {
                "type": "string",
                "description": "Reference to the name of another extra ingress to share its container port"
              },
              "protocol": {
                "type": "string",
                "default": "http",
                "enum": ["http", "https", "h2c", "grpc", "http2", "h2", "grpcs"],
                "description": "The protocol used for the port"
              },
              "timeoutSeconds": {
                "type": ["integer", "null"],
                "description": "Number of seconds after which to timeout waiting for response from service; -1 for infinite"
              },
              "domains": {
                "type": "array",
                "items": {"type": "string"},
                "description": "The public domain names under which the port is exposed (leave empty for cluster-internal only)"
              },
              "paths": {
                "type": "array",
                "items": {"type": "string"},
                "description": "HTTP path prefixes to accept ingress traffic for (leave empty to accept traffic for any path)"
              },
              "tls": {
                "type": "object",
                "properties": {
                  "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Enables TLS termination at the ingress"
                  },
                  "secret": {
                    "type": "string",
                    "description": "The name of the Secret holding the TLS private key"
                  },
                  "secretNamespace": {
                    "type": "string",
                    "description": "The Kubernetes namespace containing the Secret (only applicable if class is contour)"
                  }
                }
              },
              "annotations": {
                "type": "object",
                "additionalProperties": {"type": "string"},
                "description": "Additional annotations, merged with ingress.annotations (use string 'nil' to unset existing values)"
              }
            },
            "additionalProperties": false
          },
          "description": "Additional container ports ingress traffic is routed to (not applicable if ingress.istio.enabled)"
        }
      },
      "additionalProperties": false
    },
    "netpol": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Apply network policies for the Pods"
        },
        "ingress": {
          "type": "array",
          "items": {"type": "object"},
          "description": "Ingress network policy rules to apply"
        },
        "egress": {
          "type": "array",
          "items": {"type": "object"},
          "description": "Ingress network policy rules to apply"
        }
      },
      "additionalProperties": false
    },
    "tracing": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Enables tracing with Jaeger agent (injected as sidecar)"
        },
        "probability": {
          "type": "number",
          "default": 1,
          "minimum": 0,
          "maximum": 1,
          "description": "Probability of any single trace being sampled; can be overridden for incoming requests e.g. via Istio"
        },
        "class": {
          "type": "string",
          "default": "true",
          "description": "Custom value to set for tracing sidecar injection annotations"
        },
        "insecure": {
          "type": "boolean",
          "default": true,
          "description": "By default if tracing is enabled, a sidecar is injected without TLS. Set this to false, if the sidecar serves the tracing endpoints via TLS."
        }
      },
      "additionalProperties": false
    },
    "monitoring": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Use Prometheus for monitoring / metrics scraping"
        },
        "port": {
          "type": "integer",
          "default": 9100,
          "description": "The port to be scraped for monitoring data"
        },
        "path": {
          "type": "string",
          "default": "/metrics",
          "description": "The path to be scraped for monitoring data"
        },
        "interval": {
          "type": "string",
          "default": "1m",
          "description": "The interval at which monitoring data is scraped"
        }
      },
      "additionalProperties": false
    },
    "alerting": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Deploys Prometheus alert rule for issues like like unavailable pods or high memory use"
        },
        "pod": {
          "type": "object",
          "properties": {
            "maxStartupSeconds": {
              "type": "integer",
              "default": 120,
              "description": "The maximum amount of time a Pod is allowed to take for startup"
            },
            "maxAgeSeconds": {
              "type": ["integer", "null"],
              "description": "The maximum allowed age of a Pod in seconds (useful to ensure regular deployments)"
            }
          },
          "additionalProperties": false
        },
        "restarts": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": true,
              "description": "Deploys Prometheus alert rule for unexpected container restarts"
            }
          }
        },
        "memory": {
          "type": "object",
          "properties": {
            "enabled" : {
                "type": "boolean",
                "default": true,
                "description": "Enables alerts relating to memory usage"
            },
            "maxUsageFactor": {
              "type": "number",
              "default": 0.9,
              "minimum": 0,
              "maximum": 1,
              "description": "The maximum usage factor of the memory limit"
            },
            "quotaBufferFactor": {
              "type": "number",
              "default": 1,
              "minimum": 0,
              "description": "Multiplied with resources.*.memory to determine minimum allowed unused memory quota in namespace"
            }
          },
          "additionalProperties": false
        },
        "cpu": {
          "type": "object",
          "properties": {
            "sampleInterval": {
              "type": "string",
              "default": "1m",
              "description": "The time interval in which to measure CPU usage"
            },
            "maxThrottleFactor": {
              "type": "number",
              "default": 0.01,
              "minimum": 0,
              "maximum": 1,
              "description": "The maximum fraction of the container's execution time during which it experiences CPU throttling"
            },
            "quotaBufferFactor": {
              "type": "number",
              "default": 1,
              "minimum": 0,
              "description": "Multiplied with resources.*.cpu to determine minimum allowed unused CPU quota in namespace"
            }
          },
          "additionalProperties": false
        },
        "http": {
          "type": "object",
          "properties": {
            "sampleInterval": {
              "type": "string",
              "default": "20m",
              "description": "The time interval in which to measure HTTP responses for triggering alerts"
            },
            "referenceInterval": {
              "type": "string",
              "default": "1w",
              "description": "The time interval to to compare with the sample interval to detect changes"
            },
            "maxSlowdown": {
              "type": "number",
              "default": 2.5,
              "description": "The maximum HTTP response slowdown in the sample interval compared to the reference interval"
            },
            "max4xxRatio": {
              "type": "number",
              "default": 2.5,
              "description": "The maximum HTTP 4xx ratio increase in the sample interval compared to the reference interval"
            },
            "max5xxCount": {
              "type": "number",
              "default": 0,
              "description": "The maximum number of HTTP 5xx responses (except 504) in the sample interval"
            },
            "maxTimeoutCount": {
              "type": "number",
              "default": 0,
              "description": "The maximum number of HTTP gateway timeout responses (504) in the sample interval"
            }
          },
          "additionalProperties": false
        },
        "grpc": {
          "type": "object",
          "properties": {
            "requestsMetric": {
              "type": "string",
              "default": "grpc_server_handled_total",
              "description": "The name of the Prometheus metric counting gRPC requests"
            },
            "ignoreErrorCodes": {
              "type": "array",
              "items": {"type": "string"},
              "default": [],
              "description": "Which non-successful gRPC status codes will be ignored for triggering alerts"
            },
            "sampleInterval": {
              "type": "string",
              "default": "15m",
              "description": "The time interval in which to measure gRPC responses for triggering alerts"
            },
            "referenceInterval": {
              "type": "string",
              "default": "1w",
              "description": "The time interval to to compare with the sample interval to detect changes"
            },
            "maxErrorRatio": {
              "type": "number",
              "default": 2.5,
              "description": "The maximum gRPC error ratio increase in the sample interval compared to the reference interval"
            },
            "errorDuration" : {
                "type": "string",
                "default": "",
                "description": "The duration for which the gRPC error rate has to remain elevated before triggering an alert"
            },
            "maxCriticalErrors": {
              "type": "integer",
              "default": 0,
              "description": "The maximum number of critical gRPC errors responses in the sample interval"
            },
            "criticalCodes": {
              "type": "array",
              "items": {"type": "string"},
              "default": ["Internal", "Unimplemented"],
              "description": "Which gRPC status codes are considered critical errors"
            }
          },
          "additionalProperties": false
        },
        "custom": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "metric": {
                "type": "string",
                "description": "The name of the Prometheus metric exposed by the service"
              },
              "labelMatchers": {
                "type": "string",
                "description": "Prometheus label matchers to use for filtering the metric (e.g., some_key=\"some_value\")"
              },
              "aggregate": {
                "type": "string",
                "description": "The aggregate function to use to combine metric values from multiple replicas (e.g., max or sum)"
              },
              "increaseOver": {
                "type": "string",
                "description": "A sliding window in which to calculate the increase of the metric (e.g., 10m)"
              },
              "averageOver": {
                "type": "string",
                "description": "A sliding window in which to calculate the average value of the metric (e.g., 10m)"
              },
              "round": {
                "type": "boolean",
                "default": false,
                "description": "Round the result before evaluating the predicate"
              },
              "predicate": {
                "type": "string",
                "description": "An expression that triggers the alert when the metric fulfills it"
              },
              "severity": {
                "type": "string",
                "default": "warning",
                "description": "The severity of the alert"
              },
              "topic": {
                "type": "string",
                "description": "The topic label for the alert"
              },
              "summary": {
                "type": "string",
                "description": "A short summary of the alert"
              },
              "description": {
                "type": "string",
                "description": "A longer description of the alert; can include metric labels via templating"
              }
            },
            "required": ["metric", "aggregate", "predicate", "summary", "description"],
            "additionalProperties": false
          },
          "description": "Additional alerts based on Prometheus metrics exposed by the service"
        },
        "logs": {
          "type": "object",
          "properties": {
            "countInterval": {
              "type": "string",
              "default": "5m",
              "description": "The time interval in which to count the number of messages per log level"
            },
            "levelLabel": {
              "type": "string",
              "default": "level",
              "description": "The Loki label containing the log level"
            },
            "levels": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "properties": {
                  "maxCount": {
                    "type": "integer",
                    "default": 0,
                    "description": "The maximum number of messages in the interval to allow before alerting"
                  },
                  "severity": {
                    "type": "string",
                    "default": "warning",
                    "description": "The severity of the alert when the maximum count of a messages is exceeded"
                  }
                },
                "additionalProperties": false
              },
              "description": "Alerts for messages of specific log levels"
            },
            "lokiConfigMap": {
              "type": "object",
              "properties": {
                "label": {
                  "type": "string",
                  "default": "loki_rule",
                  "description": "The label attached to the ConfigMap holding the Loki Rules"
                },
                "labelValue": {
                  "type": "string",
                  "default": "",
                  "description": "The value of the label attached to the Loki Rule ConfigMap"
                }
              },
              "additionalProperties": false
            },
            "createLokiRule": {
              "type": "boolean",
              "default": false,
              "description": "Whether to create a LokiRule custom resource instead of a ConfigMap for log alerting"
            },
            "custom": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "properties": {
                  "regex": {
                    "type": "string",
                    "description": "Regular expression to use for matching log lines"
                  },
                  "labelMatchers": {
                    "type": "string",
                    "description": "Loki label matchers to use for matching log lines (e.g., some_key=\"some_value\")"
                  },
                  "countInterval": {
                    "type": "string",
                    "description": "The time interval in which to count the number of matching log lines"
                  },
                  "predicate": {
                    "type": "string",
                    "description": "An expression that triggers the alert when the number of matching log lines fulfills it"
                  },
                  "severity": {
                    "type": "string",
                    "default": "warning",
                    "description": "The severity of the alert"
                  },
                  "topic": {
                    "type": "string",
                    "default": "logs",
                    "description": "The topic label for the alert"
                  },
                  "summary": {
                    "type": "string",
                    "description": "A short summary of the alert"
                  },
                  "description": {
                    "type": "string",
                    "description": "A longer description of the alert; can include log labels via templating"
                  }
                },
                "required": ["predicate", "summary", "description"],
                "additionalProperties": false
              },
              "description": "Additional alerts based on Prometheus metrics exposed by the service"
            }
          },
          "additionalProperties": false
        },
        "additionalProperties": false
      }
    },
    "sidecars": {
      "type": "array",
      "items": {"type": "object"},
      "description": "Additional sidecar containers to be added to the Pod"
    },
    "sidecarsTemplates": {
      "type": "array",
      "items": {"type": "string"},
      "description": "Strings to be templated providing additional sidecar containers to be added to the Pod"
    },
    "initContainers": {
      "type": "array",
      "items": {"type": "object"},
      "description": "Additional init containers to be added to the Pod"
    },
    "initContainerTemplates": {
      "type": "array",
      "items": {"type": "string"},
      "description": "Strings to be templated providing additional init containers to be added to the Pod"
    },
    "rbac": {
      "type": "object",
      "properties": {
        "roles": {
          "type": "array",
          "items": {"type": "string"},
          "description": "Namespace-specific Kubernetes RBAC Roles to assign to the service (supports templating)"
        },
        "clusterRoles": {
          "type": "array",
          "items": {"type": "string"},
          "description": "Cluster-wide Kubernetes RBAC Roles to assign to the service (supports templating)"
        },
        "existingServiceAccount": {
          "type": "string",
          "description": "The name of an existing service account to use (instead of automatically creating one for the service)"
        }
      },
      "additionalProperties": false
    },
    "global": {
      "type": "object",
      "properties": {
        "alertLabels": {
          "type": "object",
          "additionalProperties": {"type": "string"},
          "description": "Additional labels to apply to alert rules"
        },
        "grafana": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL of a Grafana instance with access to the service's metrics"
            },
            "dashboard": {
              "type": "string",
              "default": "qqsCbY5Zz",
              "description": "The UID of the Grafana dashboard visualizing the service's metrics"
            },
            "queryVariables": {
              "type": "object",
              "default": {},
              "additionalProperties": {"type": "string"},
              "description": "Additional variables to be used in the to parametrize the service's Grafana dashboard"
            }
          }
        }
      }
    }
  },
  "required": [
    "image"
  ]
}
