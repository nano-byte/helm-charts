{
  "$schema": "https://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "description": "The name of the service (used for app.kubernetes.io/name label)"
    },
    "fullname": {
      "type": "string",
      "description": "The name of the service instance (used for resource names and app.kubernetes.io/instance label)"
    },
    "version": {
      "type": "string",
      "description": "The version of the service (used for app.kubernetes.io/version label)"
    },
    "image": {
      "type": "object",
      "properties": {
        "registry": {
          "type": "string",
          "default": "docker.io",
          "description": "The Registry containing the image to run"
        },
        "repository": {
          "type": "string",
          "description": "The name of the image image to run (without the Registry)"
        },
        "tag": {
          "type": "string",
          "description": "The tag of the image to run; start with @ for digest instead of tag (e.g., @sha256:abc...)"
        },
        "pullPolicy": {
          "type": "string",
          "enum": [
            "Never",
            "IfNotPresent",
            "Always"
          ],
          "default": "IfNotPresent",
          "description": "Set to Always to try to pull new versions of the image"
        },
        "pullSecret": {
          "type": "string",
          "description": "Name of the Kubernetes Secret providing credentials for pulling the image"
        }
      },
      "required": [
        "repository",
        "tag"
      ],
      "additionalProperties": false
    },
    "securityContext": {
      "type": "object",
      "description": "Security context",
      "properties": {
        "pod": {
          "type": "object",
          "description": "Security context to use for the pod",
          "properties": {
            "runAsUser": {
              "type": "integer"
            },
            "runAsGroup": {
              "type": "integer"
            },
            "fsGroup": {
              "type": "integer"
            }
          }
        },
        "container": {
          "type": "object",
          "description": "Security context to use for running containers",
          "properties": {
            "allowPrivilegeEscalation": {
              "type": "boolean"
            },
            "readOnlyRootFilesystem": {
              "type": "boolean"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "command": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "description": "Overrides the command to launch in the image"
    },
    "args": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "description": "The command-line arguments passed to the service"
    },
    "env": {
      "type": "object",
      "additionalProperties": {
        "type": [
          "string",
          "number",
          "boolean"
        ]
      },
      "description": "Environment variables passed to the service as a key-value map"
    },
    "envFrom": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "fieldRef": {
            "type": "object"
          },
          "resourceFieldRef": {
            "type": "object"
          },
          "configMapKeyRef": {
            "type": "object"
          },
          "secretKeyRef": {
            "type": "object"
          }
        }
      },
      "description": "Environment variables passed to the service from other sources (e.g., secretKeyRef)"
    },
    "config": {
      "type": "object",
      "description": "YAML/JSON configuration to be mounted as a file in the container"
    },
    "configMountPath": {
      "type": "string",
      "default": "/config/config.yaml",
      "description": "The file path in the container to mount the data from config into (exposed via $CONFIG_FILE)"
    },
    "additionalConfigs": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "description": "Additional ConfigMaps with key named data.yaml to be mounted (paths appended to $CONFIG_FILE)"
    },
    "dnsConfig": {
      "type": "object",
      "properties": {
        "nameservers": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "searches": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "options": {
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      },
      "description": "DNS config for the pod (https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/"
    },
    "startupProbe": {
      "type": "object",
      "description": "Probe that waits for the service to initially start",
      "properties": {
        "initialDelaySeconds": {
          "type": "integer"
        },
        "periodSeconds": {
          "type": "integer"
        },
        "httpGet": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "port": {
              "type": "string"
            },
            "path": {
              "type": "string"
            }
          },
          "additionalProperties": true
        },
        "grpc": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "port": {
              "type": "integer"
            }
          },
          "additionalProperties": true
        },
        "exec": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "command": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "additionalProperties": true
          }
        },
        "additionalProperties": true
      }
    },
    "livenessProbe": {
      "type": "object",
      "description": "Probe that causes the service to be restarted when failing",
      "properties": {
        "initialDelaySeconds": {
          "type": "integer"
        },
        "periodSeconds": {
          "type": "integer"
        },
        "httpGet": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "port": {
              "type": "string"
            },
            "path": {
              "type": "string"
            }
          },
          "additionalProperties": true
        },
        "grpc": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "port": {
              "type": "integer"
            }
          },
          "additionalProperties": true
        },
        "exec": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "command": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "additionalProperties": true
        }
      },
      "additionalProperties": true
    },
    "readinessProbe": {
      "type": "object",
      "description": "Probe that prevents the service from receiving traffic when failing",
      "properties": {
        "initialDelaySeconds": {
          "type": "integer"
        },
        "periodSeconds": {
          "type": "integer"
        },
        "httpGet": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "port": {
              "type": "string"
            },
            "path": {
              "type": "string"
            }
          },
          "additionalProperties": true
        },
        "grpc": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "port": {
              "type": "integer"
            }
          },
          "additionalProperties": true
        },
        "exec": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "command": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "additionalProperties": true
        }
      },
      "additionalProperties": true
    },
    "maxShutdownSeconds": {
      "type": "integer",
      "default": 30,
      "description": "The number of seconds the pod has to shutdown before it is terminated"
    },
    "labels": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      },
      "description": "Additional labels to set on all generated resources"
    },
    "annotations": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      },
      "description": "Additional annotations to set on the Pod controller and Pods"
    },
    "resources": {
      "type": "object",
      "properties": {
        "requests": {
          "type": "object",
          "properties": {
            "memory": {
              "type": "string",
              "default": "64M",
              "description": "The amount of memory requested for the service (recommendation: slightly higher than average usage)"
            },
            "cpu": {
              "type": "string",
              "default": "10m",
              "description": "The number of CPU cores requested for the service"
            }
          }
        },
        "limits": {
          "type": "object",
          "properties": {
            "memory": {
              "type": "string",
              "default": "96Mi",
              "description": "The maximum amount of memory the service may use (recommendation: slightly higher than worst-case usage)"
            },
            "cpu": {
              "type": "string",
              "default": "2000m",
              "description": "The maximum number of CPU cores the service may use"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "rollout": {
      "type": "object",
      "properties": {
        "controller": {
          "type": "string",
          "enum": [
            "Deployment",
            "StatefulSet",
            "DaemonSet",
            "ArgoRollout"
          ],
          "default": "Deployment",
          "description": "The type of Pod controller to create"
        },
        "strategy": {
          "type": "string",
          "enum": [
            "RollingUpdate",
            "Recreate",
            "OnDelete",
            "Canary",
            "BlueGreen"
          ],
          "default": "RollingUpdate",
          "description": "The rollout strategy"
        },
        "autoPromotion": {
          "type": "boolean",
          "default": true,
          "description": "Automatically promote successful rollouts (only applicable if rollout.strategy is BlueGreen)"
        },
        "flagger": {
          "type": "boolean",
          "default": false,
          "description": "Use Flagger to control rollouts (rollout.controller must be Deployment or StatefulSet)"
        },
        "analysis": {
          "description": "Flagger or Argo Rollouts analysis for automatic Canary or BlueGreen promotion"
        },
        "revisionHistoryLimit": {
          "type": [
            "integer",
            "null"
          ],
          "description": "Number of old ReplicaSets to retain (rollout.controller must be Deployment or ArgoRollout)"
        }
      },
      "additionalProperties": false
    },
    "replicas": {
      "type": "integer",
      "default": 1,
      "description": "The number of instances of the service to run"
    },
    "autoscaling": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Enables automatic starting of additional instances"
        },
        "maxReplicas": {
          "type": "integer",
          "default": 3,
          "description": "The maximum number of instances to run (must be larger than replicas)"
        },
        "metric": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Resource",
                "Pods",
                "Object",
                "External"
              ],
              "default": "Resource",
              "description": "The type of metric to use for scaling"
            },
            "name": {
              "type": "string",
              "default": "cpu",
              "description": "The name of the metric to use for scaling"
            },
            "object": {
              "type": [
                "object",
                "null"
              ],
              "properties": {
                "apiVersion": {
                  "type": "string"
                },
                "kind": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                }
              },
              "required": [
                "apiVersion",
                "kind",
                "name"
              ],
              "description": "Reference to the Kubernetes object the metric describes (required if type = Object)"
            },
            "selector": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              },
              "description": "Labels for selecting the metric"
            }
          }
        },
        "targetValue": {
          "type": "integer",
          "default": 80,
          "description": "The desired value of the metric to achieve through scaling (e.g., CPU utilization in percent)"
        },
        "behavior": {
          "type": "object",
          "description": "Scaling behavior configuration (see HorizontalPodAutoscalerBehavior)"
        }
      },
      "additionalProperties": false
    },
    "scheduling": {
      "type": "object",
      "properties": {
        "priority": {
          "type": "string",
          "description": "The name of the PriorityClass to use for scheduling this service"
        },
        "nodeSelector": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to select nodes this service may be run on"
        },
        "nodePreferences": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "description": "Sets of label values to select nodes this service should be run on if possible"
        },
        "nodeExclusions": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "description": "Sets of label values to select nodes this service must not run on"
        },
        "tolerations": {
          "type": "array",
          "items": {
            "type": "object",
            "oneOf": [
              {
                "type": "object",
                "properties": {
                  "operator": {
                    "type": [
                      "string", 
                      "null"
                    ], 
                    "description": "Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category."
                  }, 
                  "value": {
                    "type": [
                      "string", 
                      "null"
                    ], 
                    "description": "Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string."
                  },
                  "effect": {
                    "type": [
                      "string", 
                      "null"
                    ], 
                    "description": "Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute."
                  }, 
                  "key": {
                    "type": [
                      "string", 
                      "null"
                    ], 
                    "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys."
                  }
                }
              },
              {
                "type": "string",
                "description": "Key of the taint. The operator is automatically set to Exists and the other fields would be set to null."
              }
            ]
          },
          "description": "Taints on nodes this service can tolerate"
        },
        "podAffinity": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to select other pods this service should share nodes with if possible"
        },
        "podAntiAffinity": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to select other pods this service must not share nodes with"
        },
        "replicaSpread": {
          "type": "string",
          "enum": [
            "BestEffort",
            "Strict",
            "None"
          ],
          "default": "BestEffort",
          "description": "How to spread replicas across nodes"
        },
        "minAvailable": {
          "type": ["integer", "string"],
          "default": 1,
          "description": "Minimum number of instances to keep running during cluster maintenance (only applied if this value is smaller than replicas)"
        }
      },
      "additionalProperties": false
    },
    "persistence": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Enables persistent storage for the service"
        },
        "storageClass": {
          "type": "string",
          "description": "The type of disk to use for storage instead of the cluster default"
        },
        "accessModes": {
          "type": "array",
          "default": [
            "ReadWriteOnce"
          ],
          "items": {
            "type": "string"
          },
          "description": "The support access modes the volume can be mounted with"
        },
        "size": {
          "type": "string",
          "default": "1G",
          "description": "The size of the persistent volume to create for the service"
        },
        "mountPath": {
          "type": "string",
          "description": "The mount path for the storage inside the container"
        }
      },
      "additionalProperties": false
    },
    "secrets": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "mountPath": {
            "type": "string",
            "description": "The mount path for the Secret inside the container"
          },
          "subPath": {
            "type": "string",
            "description": "The path of a single file in the Secret to mount; leave empty to mount all files"
          },
          "files": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Map of file names to base64-encoded content; leave empty to reference existing Secret"
          }
        },
        "required": [
          "mountPath"
        ],
        "additionalProperties": false
      }
    },
    "additionalMounts": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the volume"
          }
        },
        "required": [
          "name"
        ],
        "additionalProperties": true
      },
      "description": "A map of mount paths inside the container to volumes"
    },
    "ingress": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Enables ingress into the service (either cluster-internal or public)"
        },
        "shutdownDelaySeconds": {
          "type": "integer",
          "default": 5,
          "description": "The number of seconds to delay shutting down the container once no new requests are being routed to it"
        },
        "port": {
          "type": "integer",
          "default": 80,
          "description": "The container port ingress traffic is routed to"
        },
        "protocol": {
          "type": "string",
          "default": "http",
          "enum": [
            "http",
            "https",
            "h2c",
            "grpc",
            "http2",
            "h2",
            "grpcs"
          ],
          "description": "The internal protocol used for ingress"
        },
        "timeoutSeconds": {
          "type": [
            "integer",
            "null"
          ],
          "description": "Number of seconds after which to timeout waiting for response from service; -1 for infinite"
        },
        "domains": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The public domain names under which the service is exposed (leave empty for cluster-internal only)"
        },
        "paths": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "HTTP path prefixes to accept ingress traffic for (leave empty to accept traffic for any path)"
        },
        "tls": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": false,
              "description": "Enables TLS termination at the ingress (not applicable if ingress.istio.enabled)"
            },
            "secret": {
              "type": "string",
              "default": "{{ .Release.Name }}-tls",
              "description": "The name of the Secret holding the TLS private key (not applicable if ingress.istio.enabled)"
            },
            "secretNamespace": {
              "type": "string",
              "description": "The Kubernetes namespace containing the Secret (only applicable if ingress.class is contour)"
            }
          },
          "additionalProperties": false
        },
        "cors": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": false,
              "description": "Enables CORS (only applicable if ingress.class is 'nginx' or ingress.istio.enabled is true)"
            },
            "allowOrigin": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of origins allowed to access the ingress via CORS; leave empty to allow any"
            },
            "allowMethods": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [
                "GET"
              ],
              "description": "List of HTTP methods allowed to access the ingress via CORS"
            },
            "allowHeaders": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [
                "Content-Type"
              ],
              "description": "List of HTTP headers that can be used when requesting the ingress via CORS"
            },
            "allowCredentials": {
              "type": "boolean",
              "default": true,
              "description": "Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials"
            },
            "exposeHeaders": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of HTTP headers that the browsers are allowed to access"
            }
          },
          "additionalProperties": false
        },
        "class": {
          "type": "string",
          "description": "The ingress controller to use (not applicable if ingress.istio.enabled)"
        },
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations for Ingress or VirtualService resource"
        },
        "headless": {
          "type": "boolean",
          "default": false,
          "description": "Creates an additional Service with the suffix '-headless' that directly exposes Pod IPs"
        },
        "headlessExposesAll": {
          "type": "boolean",
          "default": false,
          "description": "Exposes all replicas, including unready ones, via the '-headless' Service"
        },
        "nodeLocal": {
          "type": "boolean",
          "default": false,
          "description": "Creates an additional Service with the suffix '-local' that only routes to pods on the same node"
        },
        "additionalSelectors": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional label selectors used to restrict the Pods selected by the Service."
        },
        "istio": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": false,
              "description": "Use Istio VirtualService instead of Kubernetes Ingress resource"
            },
            "gateways": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The names of the Istio Gateways to use"
            },
            "httpHeaders": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              },
              "description": "Custom HTTP response headers"
            },
            "retries": {
              "type": "object",
              "description": "Istio retry policy (see https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRetry)"
            }
          },
          "additionalProperties": false
        },
        "extra": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "class": {
                "type": "string",
                "description": "Additional ingress controller to use (not applicable if ingress.istio.enabled)"
              },
              "port": {
                "type": "integer",
                "description": "The container port ingress traffic is routed to; defaults to value of ingress.port if not set"
              },
              "portRef": {
                "type": "string",
                "description": "Reference to the name of another extra ingress to share its container port"
              },
              "protocol": {
                "type": "string",
                "default": "http",
                "enum": [
                  "http",
                  "https",
                  "h2c",
                  "grpc",
                  "http2",
                  "h2",
                  "grpcs"
                ],
                "description": "The protocol used for the port"
              },
              "timeoutSeconds": {
                "type": [
                  "integer",
                  "null"
                ],
                "description": "Number of seconds after which to timeout waiting for response from service; -1 for infinite"
              },
              "domains": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "The public domain names under which the port is exposed (leave empty for cluster-internal only)"
              },
              "paths": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "HTTP path prefixes to accept ingress traffic for (leave empty to accept traffic for any path)"
              },
              "tls": {
                "type": "object",
                "properties": {
                  "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Enables TLS termination at the ingress"
                  },
                  "secret": {
                    "type": "string",
                    "description": "The name of the Secret holding the TLS private key"
                  },
                  "secretNamespace": {
                    "type": "string",
                    "description": "The Kubernetes namespace containing the Secret (only applicable if class is contour)"
                  }
                }
              },
              "annotations": {
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                },
                "description": "Additional annotations, merged with ingress.annotations (use string 'nil' to unset existing values)"
              }
            },
            "additionalProperties": false
          },
          "description": "Additional container ports ingress traffic is routed to (not applicable if ingress.istio.enabled)"
        }
      },
      "additionalProperties": false
    },
    "netpol": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Apply network policies for the Pods"
        },
        "ingress": {
          "type": "array",
          "items": {
            "type": "object"
          },
          "description": "Ingress network policy rules to apply"
        },
        "egress": {
          "type": "array",
          "items": {
            "type": "object"
          },
          "description": "Ingress network policy rules to apply"
        }
      },
      "additionalProperties": false
    },
    "tracing": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Enables tracing with Jaeger agent (injected as sidecar)"
        },
        "probability": {
          "type": "number",
          "default": 1,
          "minimum": 0,
          "maximum": 1,
          "description": "Probability of any single trace being sampled; can be overridden for incoming requests e.g. via Istio"
        },
        "class": {
          "type": "string",
          "default": "true",
          "description": "Custom value to set for tracing sidecar injection annotations"
        },
        "insecure": {
          "type": "boolean",
          "default": true,
          "description": "By default if tracing is enabled, a sidecar is injected without TLS. Set this to false, if the sidecar serves the tracing endpoints via TLS."
        }
      },
      "additionalProperties": false
    },
    "monitoring": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Use Prometheus for monitoring / metrics scraping"
        },
        "port": {
          "type": "integer",
          "default": 9100,
          "description": "The port to be scraped for monitoring data"
        },
        "path": {
          "type": "string",
          "default": "/metrics",
          "description": "The path to be scraped for monitoring data"
        },
        "interval": {
          "type": "string",
          "default": "1m",
          "description": "The interval at which monitoring data is scraped"
        }
      },
      "additionalProperties": false
    },
    "alerting": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Deploys Prometheus alert rule for issues like like unavailable pods or high memory use"
        },
        "pod": {
          "type": "object",
          "properties": {
            "maxStartupSeconds": {
              "type": "integer",
              "default": 120,
              "description": "The maximum amount of time a Pod is allowed to take for startup"
            },
            "maxAgeSeconds": {
              "type": [
                "integer",
                "null"
              ],
              "description": "The maximum allowed age of a Pod in seconds (useful to ensure regular deployments)"
            }
          },
          "additionalProperties": false
        },
        "restarts": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": true,
              "description": "Deploys Prometheus alert rule for unexpected container restarts"
            }
          }
        },
        "memory": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": true,
              "description": "Enables alerts relating to memory usage"
            },
            "maxUsageFactor": {
              "type": "number",
              "default": 0.9,
              "minimum": 0,
              "maximum": 1,
              "description": "The maximum usage factor of the memory limit"
            },
            "quotaBufferFactor": {
              "type": "number",
              "default": 1,
              "minimum": 0,
              "description": "Multiplied with resources.*.memory to determine minimum allowed unused memory quota in namespace"
            }
          },
          "additionalProperties": false
        },
        "cpu": {
          "type": "object",
          "properties": {
            "sampleInterval": {
              "type": "string",
              "default": "1m",
              "description": "The time interval in which to measure CPU usage"
            },
            "maxThrottleFactor": {
              "type": "number",
              "default": 0.01,
              "minimum": 0,
              "maximum": 1,
              "description": "The maximum fraction of the container's execution time during which it experiences CPU throttling"
            },
            "quotaBufferFactor": {
              "type": "number",
              "default": 1,
              "minimum": 0,
              "description": "Multiplied with resources.*.cpu to determine minimum allowed unused CPU quota in namespace"
            }
          },
          "additionalProperties": false
        },
        "http": {
          "type": "object",
          "properties": {
            "sampleInterval": {
              "type": "string",
              "default": "20m",
              "description": "The time interval in which to measure HTTP responses for triggering alerts"
            },
            "referenceInterval": {
              "type": "string",
              "default": "1w",
              "description": "The time interval to to compare with the sample interval to detect changes"
            },
            "maxSlowdown": {
              "type": "number",
              "default": 2.5,
              "description": "The maximum HTTP response slowdown in the sample interval compared to the reference interval"
            },
            "max4xxRatio": {
              "type": "number",
              "default": 2.5,
              "description": "The maximum HTTP 4xx ratio increase in the sample interval compared to the reference interval"
            },
            "maxClientCancellationRatio": {
              "type": "number",
              "default": 2.5,
              "description": "The maximum client cancellation ratio increase in the sample interval compared to the reference interval"
            },
            "max5xxCount": {
              "type": "number",
              "default": 0,
              "description": "The maximum number of HTTP 5xx responses (except 504) in the sample interval"
            },
            "maxTimeoutCount": {
              "type": "number",
              "default": 0,
              "description": "The maximum number of HTTP gateway timeout responses (504) in the sample interval"
            }
          },
          "additionalProperties": false
        },
        "grpc": {
          "type": "object",
          "properties": {
            "requestsMetric": {
              "type": "string",
              "default": "grpc_server_handled_total",
              "description": "The name of the Prometheus metric counting gRPC requests"
            },
            "sampleInterval": {
              "type": "string",
              "default": "15m",
              "description": "The time interval in which to measure gRPC responses for triggering alerts"
            },
            "referenceInterval": {
              "type": "string",
              "default": "1w",
              "description": "The time interval to to compare with the sample interval to detect changes"
            },
            "maxErrorRatio": {
              "type": "number",
              "default": 2.5,
              "description": "The maximum gRPC error ratio increase in the sample interval compared to the reference interval"
            },
            "errorDuration": {
              "type": "string",
              "default": "",
              "description": "The duration for which the gRPC error rate has to remain elevated before triggering an alert"
            },
            "ignoreErrorCodes": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Which non-OK gRPC status codes will be ignored for triggering alerts"
            },
            "maxCriticalErrors": {
              "type": "integer",
              "default": 0,
              "description": "The maximum number of critical gRPC errors responses in the sample interval"
            },
            "criticalCodes": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [
                "Internal",
                "Unimplemented"
              ],
              "description": "Which gRPC status codes are considered critical errors"
            }
          },
          "additionalProperties": false
        },
        "custom": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "metric": {
                "type": "string",
                "description": "The name of the Prometheus metric exposed by the service"
              },
              "labelMatchers": {
                "type": "string",
                "description": "Prometheus label matchers to use for filtering the metric (e.g., some_key=\"some_value\")"
              },
              "aggregate": {
                "type": "string",
                "description": "The aggregate function to use to combine metric values from multiple replicas (e.g., max or sum)"
              },
              "increaseOver": {
                "type": "string",
                "description": "A sliding window in which to calculate the increase of the metric (e.g., 10m)"
              },
              "averageOver": {
                "type": "string",
                "description": "A sliding window in which to calculate the average value of the metric (e.g., 10m)"
              },
              "round": {
                "type": "boolean",
                "default": false,
                "description": "Round the result before evaluating the predicate"
              },
              "predicate": {
                "type": "string",
                "description": "An expression that triggers the alert when the metric fulfills it"
              },
              "severity": {
                "type": "string",
                "default": "warning",
                "description": "The severity of the alert"
              },
              "topic": {
                "type": "string",
                "description": "The topic label for the alert"
              },
              "summary": {
                "type": "string",
                "description": "A short summary of the alert"
              },
              "description": {
                "type": "string",
                "description": "A longer description of the alert; can include metric labels via templating"
              }
            },
            "required": [
              "metric",
              "aggregate",
              "predicate",
              "summary",
              "description"
            ],
            "additionalProperties": false
          },
          "description": "Additional alerts based on Prometheus metrics exposed by the service"
        },
        "logs": {
          "type": "object",
          "properties": {
            "countInterval": {
              "type": "string",
              "default": "5m",
              "description": "The time interval in which to count the number of messages per log level"
            },
            "levelLabel": {
              "type": "string",
              "default": "level",
              "description": "The Loki label containing the log level"
            },
            "levels": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "properties": {
                  "maxCount": {
                    "type": "integer",
                    "default": 0,
                    "description": "The maximum number of messages in the interval to allow before alerting"
                  },
                  "severity": {
                    "type": "string",
                    "default": "warning",
                    "description": "The severity of the alert when the maximum count of a messages is exceeded"
                  }
                },
                "additionalProperties": false
              },
              "description": "Alerts for messages of specific log levels"
            },
            "lokiConfigMap": {
              "type": "object",
              "properties": {
                "label": {
                  "type": "string",
                  "default": "loki_rule",
                  "description": "The label attached to the ConfigMap holding the Loki Rules"
                },
                "labelValue": {
                  "type": "string",
                  "default": "",
                  "description": "The value of the label attached to the Loki Rule ConfigMap"
                }
              },
              "additionalProperties": false
            },
            "createLokiRule": {
              "type": "boolean",
              "default": false,
              "description": "Whether to create a LokiRule custom resource instead of a ConfigMap for log alerting"
            },
            "custom": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "properties": {
                  "regex": {
                    "type": "string",
                    "description": "Regular expression to use for matching log lines"
                  },
                  "labelMatchers": {
                    "type": "string",
                    "description": "Loki label matchers to use for matching log lines (e.g., some_key=\"some_value\")"
                  },
                  "countInterval": {
                    "type": "string",
                    "description": "The time interval in which to count the number of matching log lines"
                  },
                  "predicate": {
                    "type": "string",
                    "description": "An expression that triggers the alert when the number of matching log lines fulfills it"
                  },
                  "severity": {
                    "type": "string",
                    "default": "warning",
                    "description": "The severity of the alert"
                  },
                  "topic": {
                    "type": "string",
                    "default": "logs",
                    "description": "The topic label for the alert"
                  },
                  "summary": {
                    "type": "string",
                    "description": "A short summary of the alert"
                  },
                  "description": {
                    "type": "string",
                    "description": "A longer description of the alert; can include log labels via templating"
                  }
                },
                "required": [
                  "predicate",
                  "summary",
                  "description"
                ],
                "additionalProperties": false
              },
              "description": "Additional alerts based on Prometheus metrics exposed by the service"
            }
          },
          "additionalProperties": false
        },
        "additionalProperties": false
      }
    },
    "sidecars": {
      "type": "array",
      "items": {
        "type": "object"
      },
      "description": "Additional sidecar containers to be added to the Pod"
    },
    "sidecarsTemplates": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "description": "Strings to be templated providing additional sidecar containers to be added to the Pod"
    },
    "initContainers": {
      "type": "array",
      "items": {
        "type": "object"
      },
      "description": "Additional init containers to be added to the Pod"
    },
    "initContainerTemplates": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "description": "Strings to be templated providing additional init containers to be added to the Pod"
    },
    "rbac": {
      "type": "object",
      "properties": {
        "roles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Names of namespace-specific Kubernetes RBAC Roles to assign to the service (supports templating)"
        },
        "clusterRoles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Names of cluster-wide Kubernetes RBAC Roles to assign to the service (supports templating)"
        },
        "customRoles": {
          "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "object",
              "properties": {
                "apiGroups": {
                  "type": "array",
                  "items": {"type": "string"}
                },
                "resources": {
                  "type": "array",
                  "items": {"type": "string"}
                },
                "resourceNames": {
                  "type": "array",
                  "items": {"type": "string"}
                },
                "verbs": {
                  "type": "array",
                  "items": {"type": "string"}
                }
              },
              "required": ["apiGroups", "resources", "verbs"]
            }
          },
          "description": "Namespace-specific Kubernetes RBAC Roles to create and assign to the service (name supports templating)."
        },
        "existingServiceAccount": {
          "type": "string",
          "description": "The name of an existing service account to use (instead of automatically creating one for the service)"
        }
      },
      "additionalProperties": false
    },
    "global": {
      "type": "object",
      "properties": {
        "alertLabels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional labels to apply to alert rules"
        },
        "grafana": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL of a Grafana instance with access to the service's metrics"
            },
            "dashboard": {
              "type": "string",
              "default": "qqsCbY5Zz",
              "description": "The UID of the Grafana dashboard visualizing the service's metrics"
            },
            "queryVariables": {
              "type": "object",
              "default": {},
              "additionalProperties": {
                "type": "string"
              },
              "description": "Additional variables to be used in the to parametrize the service's Grafana dashboard"
            }
          }
        }
      }
    }
  },
  "required": [
    "image"
  ]
}
